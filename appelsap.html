<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Appelsap - joshthedev888.github.io</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1c3c;
            font-family: 'Inter', sans-serif;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .ui-box {
            position: absolute;
            color: white;
            padding: 12px 20px;
            background: rgba(20, 20, 40, 0.85); 
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.8);
            z-index: 10;
            text-align: center;
            line-height: 1.4;
            border: 2px solid #a855f7; 
        }

        .menu-button {
            display: block;
            padding: 8px 10px;
            background: #a855f7;
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: bold;
            transition: background 0.2s;
            cursor: pointer;
        }
        .menu-button:hover {
            background: #8b3abf;
        }
        
        #menu-box {
            top: 20px;
            left: 20px;
            transform: none;
            max-width: 150px;
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
        }

        #controls {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.1em;
            width: 90%;
            max-width: 400px;
        }

        #score-box {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 300px;
            font-size: 1.2em;
            color: #fff;
            background: rgba(42, 42, 68, 0.8);
            border: 2px solid #a855f7;
        }

        .score-value {
            color: #fca311; 
            font-weight: bold;
            display: inline-block;
            min-width: 50px;
        }

        @media (max-width: 600px) {
            #controls {
                font-size: 0.9em;
                padding: 8px 15px;
            }
            #score-box {
                top: 10px;
                font-size: 1em;
                padding: 8px 15px;
            }
            #menu-box {
                top: 10px;
                left: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
    </div>
    
    <div id="menu-box" class="ui-box">
        <a href="index.html" class="menu-button">Terug naar Menu</a>
    </div>

    <div id="score-box" class="ui-box">
        Score: <span id="score-value" class="score-value">0</span> |
        Hoogste Score: <span id="high-score-value" class="score-value">0</span>
    </div>

    <div id="controls" class="ui-box">
        Gebruik W A S D of Pijltjestoetsen om te bewegen.
        <br>
        Gebruik SPATIE om te springen of te wall jumpen.
    </div>

    <script>
        let scene, camera, renderer;
        let world, timeStep = 1 / 60;
        let playerBody, playerMesh;
        let controls = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false,
            canJump: true
        };

        const jumpVelocity = 11;
        const moveSpeed = 60;
        const wallJumpVerticalVelocity = 40;
        const wallJumpHorizontalFactor = 0.1;
        let lastTime;

        let score = 0;
        let highScore = 0;
        let lastPlatformZ = 0;
        let platformMeshes = [];
        let platformBodies = [];
        let laserMeshes = [];
        let laserBodies = [];
        const PLAYER_HEIGHT = 1.8;
        
        let wallContactX = 0;
        let wallContactZ = 0;

        function loadHighScore() {
            const storedScore = localStorage.getItem('platformerHighScore');
            if (storedScore) {
                highScore = parseInt(storedScore, 10);
            }
            document.getElementById('high-score-value').textContent = highScore;
        }

        function saveHighScore() {
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('platformerHighScore', highScore);
                document.getElementById('high-score-value').textContent = highScore;
            }
        }

        function updateScore() {
            const currentScore = Math.floor(-playerBody.position.z);
            if (currentScore > score) {
                score = currentScore;
                document.getElementById('score-value').textContent = score;
                saveHighScore();
            }
        }

        function initThree() {
            const twilightColor = 0x1a1c3c;
            scene = new THREE.Scene();
            scene.background = new THREE.Color(twilightColor); 
            scene.fog = new THREE.Fog(twilightColor, 15, 120); 

            const container = document.getElementById('game-container');
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 5, 8);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            const hemiLight = new THREE.HemisphereLight(0xeeeeff, 0x111122, 1.5); 
            scene.add(hemiLight);

            const directionalLight = new THREE.DirectionalLight(0xffccaa, 1);
            directionalLight.position.set(10, 30, 10);
            directionalLight.target.position.set(0, 0, 0); 
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
        }

        function initCannon() {
            world = new CANNON.World();
            world.gravity.set(0, -30, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
        }

        function createPlayer() {
            const playerShape = new CANNON.Cylinder(0.5, 0.5, PLAYER_HEIGHT, 16);
            const q = new CANNON.Quaternion();
            q.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);

            playerBody = new CANNON.Body({
                mass: 5,
                position: new CANNON.Vec3(0, 5, 0),
                fixedRotation: true
            });
            playerBody.addShape(playerShape, new CANNON.Vec3(), q);
            world.addBody(playerBody);

            playerMesh = new THREE.Group();
            const skinColor = 0xffe0bd;
            const clothingColor = 0x0077b6;
            
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshPhongMaterial({ color: skinColor });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.9; 
            head.castShadow = true;
            playerMesh.add(head);

            const torsoGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.4);
            const torsoMaterial = new THREE.MeshPhongMaterial({ color: clothingColor });
            const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
            torso.position.y = 0.4;
            torso.castShadow = true;
            playerMesh.add(torso);

            const legGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.9, 8);
            const legMaterial = new THREE.MeshPhongMaterial({ color: clothingColor });

            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, -0.45, 0);
            leftLeg.castShadow = true;
            playerMesh.add(leftLeg);
            playerMesh.leftLeg = leftLeg;

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, -0.45, 0);
            rightLeg.castShadow = true;
            playerMesh.add(rightLeg);
            playerMesh.rightLeg = rightLeg;
            
            const armGeometry = new THREE.BoxGeometry(0.2, 0.6, 0.2);
            const armMaterial = new THREE.MeshPhongMaterial({ color: skinColor });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.4, 0.4, 0);
            leftArm.castShadow = true;
            playerMesh.add(leftArm);
            playerMesh.leftArm = leftArm;

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.4, 0.4, 0);
            rightArm.castShadow = true;
            playerMesh.add(rightArm);
            playerMesh.rightArm = rightArm;
            
            scene.add(playerMesh);

            playerBody.addEventListener('collide', (e) => {
                const contactNormal = new CANNON.Vec3();
                const upAxis = new CANNON.Vec3(0, 1, 0);
                const contact = e.contact;
                const sideThreshold = 0.2;

                if (contact.bi.id === playerBody.id) {
                    contact.ni.negate(contactNormal);
                } else {
                    contactNormal.copy(contact.ni);
                }

                if (contactNormal.dot(upAxis) > 0.5) {
                    controls.canJump = true;
                } else if (Math.abs(contactNormal.dot(upAxis)) < sideThreshold) { 
                    wallContactX = contactNormal.x;
                    wallContactZ = contactNormal.z;
                }
            });
        }

        function createPlatform(x, y, z, w, h, d, color, rotationY = 0) {
            const geometry = new THREE.BoxGeometry(w, h, d);
            const material = new THREE.MeshPhongMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.rotation.y = rotationY;
            mesh.receiveShadow = true;
            mesh.castShadow = true;
            scene.add(mesh);
            platformMeshes.push(mesh);

            const shape = new CANNON.Box(new CANNON.Vec3(w / 2, h / 2, d / 2));
            const body = new CANNON.Body({ mass: 0, position: new CANNON.Vec3(x, y, z) });
            
            if (rotationY !== 0) {
                const q = new CANNON.Quaternion();
                q.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), rotationY);
                body.quaternion.copy(q);
            }

            body.addShape(shape);
            world.addBody(body);
            platformBodies.push(body);
        }

        function createLaser(x, y, z, w, h, d) {
            const laserColor = 0xff0000;
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(w, h, d),
                new THREE.MeshBasicMaterial({ color: laserColor, transparent: true, opacity: 0.7 })
            );
            mesh.position.set(x, y, z);
            scene.add(mesh);
            laserMeshes.push(mesh);

            const shape = new CANNON.Box(new CANNON.Vec3(w / 2, h / 2, d / 2));
            const body = new CANNON.Body({ mass: 0, position: new CANNON.Vec3(x, y, z) });
            
            body.addShape(shape);
            world.addBody(body);
            laserBodies.push(body);
        }

        function cleanupPlatforms() {
            const cleanupZ = playerBody.position.z + 20;

            for (let i = platformBodies.length - 1; i >= 0; i--) {
                const body = platformBodies[i];
                if (i > 0 && body.position.z > cleanupZ) { 
                    world.removeBody(body);
                    scene.remove(platformMeshes[i]);
                    platformMeshes[i].geometry.dispose();
                    platformMeshes[i].material.dispose();

                    platformBodies.splice(i, 1);
                    platformMeshes.splice(i, 1);
                }
            }

            for (let i = laserBodies.length - 1; i >= 0; i--) {
                const body = laserBodies[i];
                if (body.position.z > cleanupZ) { 
                    world.removeBody(body);
                    scene.remove(laserMeshes[i]);
                    laserMeshes[i].geometry.dispose();
                    laserMeshes[i].material.dispose();

                    laserBodies.splice(i, 1);
                    laserMeshes.splice(i, 1);
                }
            }
        }

        function generateNextSection() {
            const difficultyLevel = Math.min(1, score / 500);

            const minGap = 4 + 3 * difficultyLevel;
            const maxGap = 8 + 5 * difficultyLevel;
            const gapZ = minGap + Math.random() * (maxGap - minGap);

            const minHeightDiff = -1;
            const maxHeightDiff = 2 + 3 * difficultyLevel;
            const platformHeightDiff = minHeightDiff + Math.random() * (maxHeightDiff - minHeightDiff);

            let newZ = lastPlatformZ - gapZ;
            let newY = Math.max(0, platformBodies[platformBodies.length - 1].position.y + platformHeightDiff);
            let newX = (-10 + Math.random() * 20) * difficultyLevel * 0.5;

            const type = Math.floor(Math.random() * 5);

            const baseColor = new THREE.Color(`hsl(${Math.floor(Math.random() * 360)}, 70%, 50%)`).getHex();
            
            let platformDepth = 6;
            let platformRotationY = 0;
            let platformWidth = 8;
            let platformHeight = 0.5;

            if (Math.random() < 0.1 && type !== 4) { 
                const laserY = newY + 1.5 + Math.random() * 1.5;
                const laserZ = newZ + gapZ / 2;
                const laserWidth = 20;
                createLaser(0, laserY, laserZ, laserWidth, 0.2, 0.2);
            }


            if (type === 4) {
                const stepHeight = 1.8 + 0.5 * difficultyLevel;
                const stepGap = 2.5 - 0.5 * difficultyLevel;
                const numSteps = 3;
                
                let climbX = newX;
                let climbY = newY - stepHeight;
                let climbZ = newZ + (numSteps - 1) * stepGap; 

                for (let i = 0; i < numSteps; i++) {
                    climbY += stepHeight;
                    climbZ -= stepGap;
                    climbX += (Math.random() - 0.5) * 2;
                    
                    createPlatform(climbX, climbY, climbZ, 2.5, 0.5, 2.5, baseColor);
                }
                
                lastPlatformZ = climbZ - 2.5 / 2; 

            } else {
                switch (type) {
                    case 0:
                        platformWidth = 8 - 3 * difficultyLevel;
                        platformDepth = 6;
                        break;
                    
                    case 1:
                        platformWidth = 1.5; 
                        platformDepth = 8;
                        break;

                    case 2:
                        platformWidth = 4 - 2 * difficultyLevel; 
                        platformHeight = 3 + 4 * difficultyLevel; 
                        platformDepth = 4;
                        break;

                    case 3:
                        platformWidth = 6;
                        platformDepth = 6;
                        platformRotationY = (Math.random() - 0.5) * Math.PI * 0.15 * difficultyLevel; 
                        break;
                }

                createPlatform(newX, newY, newZ, platformWidth, platformHeight, platformDepth, baseColor, platformRotationY);
                lastPlatformZ = newZ - platformDepth / 2;
            }
        }

        function createInitialWorld() {
            createPlatform(0, 0, 0, 15, 0.5, 15, 0x44aa44);
            lastPlatformZ = -7.5;

            for (let i = 0; i < 7; i++) {
                generateNextSection();
            }
        }

        function setupControls() {
            const keyMap = {
                'w': 'forward', 'ArrowUp': 'forward',
                's': 'backward', 'ArrowDown': 'backward',
                'a': 'left', 'ArrowLeft': 'left',
                'd': 'right', 'ArrowRight': 'right',
                ' ': 'jump'
            };

            const setControlState = (key, state) => {
                const control = keyMap[key];
                if (control) controls[control] = state;
            };

            window.addEventListener('keydown', (event) => setControlState(event.key, true));
            window.addEventListener('keyup', (event) => setControlState(event.key, false));
        }

        function updatePlayerMovement(delta) {
            const currentYVelocity = playerBody.velocity.y;
            const velocityVector = new CANNON.Vec3(0, 0, 0);

            if (controls.forward) { velocityVector.z -= 1; }
            if (controls.backward) { velocityVector.z += 1; }
            if (controls.left) { velocityVector.x -= 1; }
            if (controls.right) { velocityVector.x += 1; }
            
            const moving = velocityVector.length() > 0;

            if (moving) {
                velocityVector.normalize();
            }

            if (controls.canJump) {
                if (moving) {
                    playerBody.velocity.x = velocityVector.x * moveSpeed;
                    playerBody.velocity.z = velocityVector.z * moveSpeed;
                } else {
                    playerBody.velocity.x *= 0.7; 
                    playerBody.velocity.z *= 0.7;
                }
            } else {
                const airControlSpeed = moveSpeed * 0.3;

                if (moving) {
                    const forceX = velocityVector.x * airControlSpeed * playerBody.mass;
                    const forceZ = velocityVector.z * airControlSpeed * playerBody.mass;
                    
                    playerBody.applyForce(
                        new CANNON.Vec3(forceX, 0, forceZ),
                        playerBody.position
                    );
                }
            }
            
            playerBody.velocity.y = currentYVelocity;

            let jumpUsed = false;
            
            if (controls.jump && controls.canJump) {
                playerBody.velocity.y = jumpVelocity;
                controls.canJump = false;
                jumpUsed = true;
            }

            const isTouchingWall = wallContactX !== 0 || wallContactZ !== 0;

            if (controls.jump && !controls.canJump && isTouchingWall) {
                const wallJumpStrength = moveSpeed * wallJumpHorizontalFactor; 
                
                playerBody.velocity.y = wallJumpVerticalVelocity;

                playerBody.velocity.x = 0;
                playerBody.velocity.z = 0;

                playerBody.velocity.x += wallContactX * wallJumpStrength;
                playerBody.velocity.z += wallContactZ * wallJumpStrength;

                jumpUsed = true;
            }
            
            if (jumpUsed) {
                controls.jump = false;
            }

            if (controls.canJump) {
                const horizontalSpeedSq = playerBody.velocity.x * playerBody.velocity.x + playerBody.velocity.z * playerBody.velocity.z;
                if (horizontalSpeedSq > moveSpeed * moveSpeed) {
                    const ratio = moveSpeed / Math.sqrt(horizontalSpeedSq);
                    playerBody.velocity.x *= ratio;
                    playerBody.velocity.z *= ratio;
                }
            }
        }
        
        function updateAvatarAnimation(time) {
            const speed = Math.sqrt(playerBody.velocity.x * playerBody.velocity.x + playerBody.velocity.z * playerBody.velocity.z);
            
            const animationFactor = Math.min(1, speed / moveSpeed); 
            const walkCycleSpeed = 15;
            const maxSwing = Math.PI / 4;

            const isAirborne = controls.canJump === false;

            if (animationFactor > 0 && !isAirborne) {
                const angle = Math.sin(time * walkCycleSpeed) * maxSwing * animationFactor;

                playerMesh.rightArm.rotation.x = angle * 0.7; 
                playerMesh.leftArm.rotation.x = -angle * 0.7;

                playerMesh.rightLeg.rotation.x = -angle; 
                playerMesh.leftLeg.rotation.x = angle;

            } else {
                const restAngle = 0;
                const damping = 0.15; 

                playerMesh.rightArm.rotation.x += (restAngle - playerMesh.rightArm.rotation.x) * damping;
                playerMesh.leftArm.rotation.x += (restAngle - playerMesh.leftArm.rotation.x) * damping;
                playerMesh.rightLeg.rotation.x += (restAngle - playerMesh.rightLeg.rotation.x) * damping;
                playerMesh.leftLeg.rotation.x += (restAngle - playerMesh.leftLeg.rotation.x) * damping;

                if (isAirborne) {
                     playerMesh.rightArm.rotation.x = -maxSwing / 3;
                     playerMesh.leftArm.rotation.x = maxSwing / 3;
                }
            }
        }


        function updateCamera() {
            const followDistance = 10;
            const followHeight = 5;
            const playerPos = playerBody.position;

            camera.position.x = playerPos.x;
            camera.position.y = playerPos.y + followHeight;
            camera.position.z = playerPos.z + followDistance;

            camera.lookAt(playerPos.x, playerPos.y + PLAYER_HEIGHT / 2, playerPos.z);
        }
        
        function syncPlayerMesh() {
            playerMesh.position.copy(playerBody.position);
            playerMesh.quaternion.copy(playerBody.quaternion);
        }

        function checkLaserCollision() {
            const playerPos = playerBody.position;
            const playerRadius = 0.5; 
            const playerHeight = PLAYER_HEIGHT;

            for (const laserBody of laserBodies) {
                const laserPos = laserBody.position;
                
                const w = 20, h = 0.2, d = 0.2; 
                
                const laserMinX = laserPos.x - w / 2;
                const laserMaxX = laserPos.x + w / 2;
                const laserMinY = laserPos.y - h / 2;
                const laserMaxY = laserPos.y + h / 2;
                const laserMinZ = laserPos.z - d / 2;
                const laserMaxZ = laserPos.z + d / 2;
                
                const playerMinY = playerPos.y - playerHeight / 2;
                const playerMaxY = playerPos.y + playerHeight / 2;
                
                const overlapX = playerPos.x + playerRadius > laserMinX && playerPos.x - playerRadius < laserMaxX;
                const overlapY = playerMaxY > laserMinY && playerMinY < laserMaxY;
                const overlapZ = playerPos.z + playerRadius > laserMinZ && playerPos.z - playerRadius < laserMaxZ;
                
                if (overlapX && overlapY && overlapZ) {
                    checkGameOver(); 
                    return;
                }
            }
        }


        function checkGameOver() {
            if (playerBody.position.y < -20) {
                saveHighScore();

                score = 0;
                document.getElementById('score-value').textContent = 0;

                playerBody.position.set(0, 10, 0); 
                playerBody.velocity.set(0, 0, 0);

                for (let i = platformBodies.length - 1; i >= 1; i--) { 
                    world.removeBody(platformBodies[i]);
                    scene.remove(platformMeshes[i]);
                    platformMeshes[i].geometry.dispose();
                    platformMeshes[i].material.dispose();
                }
                platformBodies.splice(1);
                platformMeshes.splice(1);
                
                for (let i = laserBodies.length - 1; i >= 0; i--) {
                    world.removeBody(laserBodies[i]);
                    scene.remove(laserMeshes[i]);
                    laserMeshes[i].geometry.dispose();
                    laserMeshes[i].material.dispose();
                }
                laserBodies.splice(0);
                laserMeshes.splice(0);

                lastPlatformZ = -7.5;
                for (let i = 0; i < 7; i++) {
                    generateNextSection();
                }
            }
        }

        function animate(currentTime) {
            requestAnimationFrame(animate);

            if (lastTime !== undefined) {
                const delta = (currentTime - lastTime) / 1000;
                
                wallContactX = 0;
                wallContactZ = 0;
                
                world.step(timeStep, delta, 3);

                updatePlayerMovement(delta);

                updateAvatarAnimation(currentTime / 1000);

                syncPlayerMesh();

                updateCamera();

                updateScore();

                checkLaserCollision();

                checkGameOver();

                if (playerBody.position.z < lastPlatformZ + 15) { 
                    generateNextSection();
                    cleanupPlatforms();
                }
            }

            renderer.render(scene, camera);
            lastTime = currentTime;
        }

        function onWindowResize() {
            const container = document.getElementById('game-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        window.onload = function() {
            initThree();
            initCannon();
            loadHighScore();
            createPlayer();
            createInitialWorld();
            setupControls();

            window.addEventListener('resize', onWindowResize);

            animate();
        };
    </script>
</body>
</html>
