<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>joshthedev888.github.io - kaas en butterchicken escape</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script> 
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Press+Start+2P&display=swap');

        :root {
            --wall-color: #222;
            --path-color: #000;
            --exit-color: #008800;
            --jumpscare-color-flash: #ff0000;
            --jumpscare-color-end: #0a0a0a;
            --monster-cm-color: #ff0000;
            --monster-bcm-color: #ff8c00;
            --item-speed-color: #00ffff;
            --player-boost-color: #00ff00;
            --player-base-color: #ffffff;

            font-family: 'Press Start 2P', monospace;
            background-color: #0d0d0d;
            color: #ccc;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 10vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            overflow: hidden;
        }

        h1 {
            font-family: 'Creepster', cursive;
            color: #d32f2f;
            text-shadow: 0 0 5px #d32f2f, 0 0 10px #800000;
            margin-bottom: 20px;
            font-size: 2rem;
            text-align: center;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
            border: 4px solid var(--wall-color);
            border-radius: 8px;
            overflow: hidden;
            background-color: var(--path-color);
        }

        canvas {
            display: block;
            touch-action: none;
            width: 600px; 
            height: 600px;
            max-width: calc(100vw - 40px);
            max-height: calc(100vh - 200px);
            background-color: var(--path-color);
        }

        #status-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        #status-message {
            margin-top: 15px;
            font-size: 0.8rem;
            color: #ffc107;
            text-align: center;
            min-height: 20px;
            opacity: 0.9;
        }

        #menu-button {
            background-color: #555;
            color: #fff;
            border: 2px solid #777;
            padding: 8px 15px;
            margin-top: 10px;
            font-size: 0.7rem;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 3px #333;
            transition: all 0.1s;
        }
        #menu-button:active {
            box-shadow: 0 1px #333;
            transform: translateY(2px);
        }
        
        #timer-bar, #player-boost-bar {
            margin-top: 5px;
            width: 90%;
            max-width: 540px;
            height: 5px;
            background-color: #333;
            border-radius: 2px;
            overflow: hidden;
            opacity: 0; 
            transition: opacity 0.3s;
        }
        
        #timer-bar.active { opacity: 1; }
        #player-boost-bar.active { opacity: 1; }

        #timer-progress {
            height: 100%;
            width: 100%; 
            background-color: var(--monster-cm-color);
            transition: width 0.1s linear;
        }
        
        #player-progress {
            height: 100%;
            width: 100%;
            background-color: var(--player-boost-color);
            transition: width 0.1s linear;
        }

        #jumpscare-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #300 0%, #000 60%, #000 100%);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 1000;
            cursor: none;
            opacity: 0;
            transition: opacity 0.08s ease-in-out;
            overflow: hidden;
        }

        #jumpscare-overlay.active {
            display: flex;
            opacity: 1;
        }

        #jumpscare-overlay.flash {
            animation: flash-disturb 0.25s steps(2) forwards;
        }

        @keyframes flash-disturb {
            0%   { background-color: #ffffff; filter: invert(1) contrast(3); }
            30%  { background-color: #ff0000; filter: contrast(2); }
            70%  { background-color: #000000; filter: none; }
            100% { background-color: #000000; }
        }

        #jumpscare-overlay::before,
        #jumpscare-overlay::after {
            content: "";
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(
                to bottom,
                rgba(255, 0, 0, 0.08),
                rgba(255, 0, 0, 0.08) 2px,
                transparent 2px,
                transparent 4px
            );
            mix-blend-mode: screen;
            opacity: 0;
            pointer-events: none;
        }

        #jumpscare-overlay.glitch::before {
            animation: glitch-scan 0.45s linear infinite;
            opacity: 1;
        }

        #jumpscare-overlay.glitch::after {
            animation: glitch-flicker 0.25s steps(3) infinite;
            opacity: 1;
        }

        @keyframes glitch-scan {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }

        @keyframes glitch-flicker {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.4; }
        }

        #jumpscare-monster {
            font-size: 8rem;
            text-shadow: 0 0 30px #ff0000, 0 0 15px #ff8c00;
            transform: scale(1.2);
            animation: monster-zoom 0.4s ease-out forwards;
            filter: drop-shadow(0 0 10px #f00);
        }

        @keyframes monster-zoom {
            0% { transform: scale(0.6) translateY(40px); opacity: 0; }
            60% { transform: scale(1.4) translateY(-10px); opacity: 1; }
            100% { transform: scale(1.1) translateY(0); }
        }

        #jumpscare-text {
            font-size: 3rem;
            color: #fff;
            text-shadow: 0 0 15px #ff0000, 0 0 5px #ff8c00;
            font-family: 'Creepster', cursive;
            user-select: none;
            line-height: 1.3;
            margin-top: 10px;
            white-space: pre-line;
            opacity: 0;
        }

        #jumpscare-caption {
            font-size: 1.2rem;
            color: #ffc107;
            margin-top: 15px;
            opacity: 0;
        }

        @keyframes screenshake {
            0% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(-10px, -10px) rotate(2deg); }
            50% { transform: translate(10px, 10px) rotate(-2deg); }
            75% { transform: translate(-5px, 5px) rotate(1deg); }
            100% { transform: translate(0, 0) rotate(0deg); }
        }

        #game-container.shake { animation: screenshake 0.12s infinite; }

        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 1s ease-out;
        }

        #loading-text {
            font-size: 1.5rem;
            margin-top: 20px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }

        @media (max-width: 600px) {
            h1 { font-size: 1.5rem; }
            #jumpscare-text { font-size: 2rem; }
            #jumpscare-monster { font-size: 5rem; }
            #jumpscare-caption { font-size: 1rem; }
        }

        #mobile-controls {
            display: grid;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            gap: 10px;
            margin-top: 20px;
            width: 200px;
        }

        .control-button {
            background-color: #333;
            color: #fff;
            border: 2px solid #555;
            padding: 15px 0;
            font-size: 1rem;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px #111;
            transition: all 0.1s;
            user-select: none;
        }

        .control-button:active {
            background-color: #555;
            box-shadow: 0 1px #111;
            transform: translateY(3px);
        }

        .control-button.up    { grid-area: up; }
        .control-button.down  { grid-area: down; }
        .control-button.left  { grid-area: left; }
        .control-button.right { grid-area: right; }

        @media (min-width: 768px) {
            #mobile-controls { display: none; }
        }
    </style>
</head>
<body>

    <h3>High Score: <span id="highScore">0</span></h3>
    
    <h1>Het Dubbele Monster Doolhof</h1>

    <h3>Score: <span id="score">0</span></h3>

    <div id="game-container">
        <canvas id="mazeCanvas"></canvas>
        
        <div id="loading-screen">
            <span style="font-size: 5rem;">üß†</span>
            <p id="loading-text">Doolhof Genereren... (2s vertraging)</p>
        </div>
        
        <div id="jumpscare-overlay">
            <div id="jumpscare-monster">üëÅÔ∏è</div>
            <p id="jumpscare-text"></p>
            <p id="jumpscare-caption"></p>
        </div>
    </div>
    
    <div id="status-area">
        <div id="timer-bar">
            <div id="timer-progress"></div>
        </div>
        
        <div id="player-boost-bar">
            <div id="player-progress"></div>
        </div>

        <div id="status-message"></div>
        <button id="menu-button" onclick="window.location.href='index.html';">Terug naar Menu</button>
    </div>

    <div id="mobile-controls">
        <button class="control-button up" ontouchstart="movePlayer('up');" ontouchend="stopMove();">‚ñ≤</button>
        <button class="control-button left" ontouchstart="movePlayer('left');" ontouchend="stopMove();">‚óÄ</button>
        <button class="control-button right" ontouchstart="movePlayer('right');" ontouchend="stopMove();">‚ñ∂</button>
        <button class="control-button down" ontouchstart="movePlayer('down');" ontouchend="stopMove();">‚ñº</button>
    </div>

    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('jumpscare-overlay');
        const statusMessage = document.getElementById('status-message');
        const gameContainer = document.getElementById('game-container');
        const timerBar = document.getElementById('timer-bar');
        const timerProgress = document.getElementById('timer-progress');
        const boostBar = document.getElementById('player-boost-bar');
        const boostProgress = document.getElementById('player-progress');
        const loadingScreen = document.getElementById('loading-screen'); 

        const GRID_SIZE = 101;
        const CELL_SIZE = 40;
        const VIEWPORT_SIZE = 800;

        const MIN_PATH_DISTANCE_SPAWN = 8; 
        const MAX_PATH_DISTANCE_SPAWN = 20; 
        
        const PLAYER_BASE_MOVE_SPEED = 150;
        const PLAYER_BOOST_MOVE_SPEED = 75;
        const MONSTER_TYPES = {
            CM: { emoji: 'üßÄ', speed: 90, name: 'Kaas' }, 
            BCM: { emoji: 'üçó', speed: 90, name: 'Butter Chicken' }  
        };
        
        let MAP = []; 
        let gameState = 'loading';
        let score = 0;

        let player = {
            x: 1, 
            y: 1,
            isBoosted: false
        };
        
        let monsters = []; 

        const PROGRESSIVE_JUMPSCARE_CHANCE = 0.30; 
        const STEPS_BEFORE_CHANCE_CHECK = 30; 
        let fearMeter = 0; 

        const CHASE_DURATION = 10000;
        const PLAYER_BOOST_TIME = 5000; 

        let chaseTimer = 0;
        let chaseIntervalId = null; 
        let playerBoostTimeout = null;
        let playerBoostInterval = null;

        let keysPressed = {};
        let playerMovementIntervalId = null;
        let currentMoveSpeed = PLAYER_BASE_MOVE_SPEED; 
        
        let noiseSynth = null;
        
        function initAudio() {
            try {
                noiseSynth = new Tone.NoiseSynth({
                    noise: { type: "white" },
                    envelope: {
                        attack: 0.005,
                        decay: 0.1,
                        sustain: 0.05,
                        release: 0.1,
                    },
                }).toDestination();
                
                Tone.context.resume();
            } catch (e) {}
        }
        
        function playJumpscareSound() {
            if (noiseSynth) {
                if (Tone.context.state !== 'running') {
                     Tone.start(); 
                }
                noiseSynth.triggerAttackRelease("4n", Tone.now()); 
                noiseSynth.triggerAttackRelease("8n", Tone.now() + 0.05, 0.8);
            }
        }

        function initializeGrid(rows, cols) {
            const grid = Array(rows).fill(0).map(() => Array(cols).fill(1)); 
            return grid;
        }

        function generateMaze(rows, cols) {
            const grid = initializeGrid(rows, cols);

            function carve(x, y) {
                if (x % 2 === 0 || y % 2 === 0) return;
                
                const directions = [
                    [0, -2], [0, 2], 
                    [-2, 0], [2, 0]  
                ];
                
                for (let i = directions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [directions[i], directions[j]] = [directions[j], directions[i]];
                }

                for (const [dx, dy] of directions) {
                    const nextX = x + dx;
                    const nextY = y + dy;

                    if (nextX > 0 && nextX < cols - 1 && nextY > 0 && nextY < rows - 1) {
                        if (grid[nextY][nextX] === 1) {
                            grid[y + dy / 2][x + dx / 2] = 0; 
                            grid[nextY][nextX] = 0; 
                            carve(nextX, nextY);
                        }
                    }
                }
            }

            grid[1][1] = 0; 
            carve(1, 1);
            grid[rows - 2][cols - 2] = 2; 

            return grid;
        }

        function findPathBFS(startX, startY, targetX = null, targetY = null) {
            const queue = [[startX, startY, 0]];
            const visited = {};
            visited[`${startX},${startY}`] = { parent: null, distance: 0 };
            
            const directions = [
                [0, -1], [0, 1], 
                [-1, 0], [1, 0]  
            ];
            
            let targetKey = targetX !== null ? `${targetX},${targetY}` : null;
            let pathFound = false;

            while (queue.length > 0) {
                const [currentX, currentY, distance] = queue.shift();
                
                if (targetKey && currentX === targetX && currentY === targetY) {
                    pathFound = true;
                    break;
                }

                for (const [dx, dy] of directions) {
                    const nextX = currentX + dx;
                    const nextY = currentY + dy;
                    const nextKey = `${nextX},${nextY}`;

                    if (nextX >= 0 && nextX < GRID_SIZE && nextY >= 0 && nextY < GRID_SIZE && 
                        MAP[nextY][nextX] !== 1 && !visited[nextKey]) {
                        
                        visited[nextKey] = { parent: { x: currentX, y: currentY }, distance: distance + 1 }; 
                        queue.push([nextX, nextY, distance + 1]);
                    }
                }
            }

            const result = { nextStep: null, distanceMap: new Map() };

            for (const key in visited) {
                const [x, y] = key.split(',').map(Number);
                result.distanceMap.set(key, visited[key].distance);
            }

            if (targetKey && pathFound) {
                let path = [];
                let current = { x: targetX, y: targetY };
                
                while (current.x !== startX || current.y !== startY) {
                    path.push(current);
                    const key = `${current.x},${current.y}`;
                    const parent = visited[key].parent;
                    
                    if (parent === null) break; 
                    current = parent;
                }
                result.nextStep = path.pop(); 
            }
            
            return result;
        }

        function startPlayerMovementLoop() {
            if (playerMovementIntervalId) {
                clearInterval(playerMovementIntervalId);
            }

            if (gameState !== 'playing' && gameState !== 'chased') return;

            playerMovementIntervalId = setInterval(() => {
                if (gameState === 'dead' || gameState === 'won') {
                    clearInterval(playerMovementIntervalId);
                    playerMovementIntervalId = null;
                    return;
                }

                let dx = 0;
                let dy = 0;

                if (keysPressed['ArrowUp'] || keysPressed['w']) dy = -1;
                else if (keysPressed['ArrowDown'] || keysPressed['s']) dy = 1;
                else if (keysPressed['ArrowLeft'] || keysPressed['a']) dx = -1;
                else if (keysPressed['ArrowRight'] || keysPressed['d']) dx = 1;

                if (dx !== 0 || dy !== 0) {
                    handleMoveStep(dx, dy);
                    score++;
                    document.getElementById("score").textContent = score;

                    if (!localStorage.getItem("highscore")) {
                        document.getElementById("highScore").textContent = "0";
                    } elif (localStorage.getItem("highscore")) {
                        
                    }
                }
            }, currentMoveSpeed);
        }

        function updatePlayerMoveSpeed(newSpeed) {
            currentMoveSpeed = newSpeed;
            startPlayerMovementLoop();
        }
        
        function startMonsterMovement(monster) {
            if (monster.intervalId) {
                clearInterval(monster.intervalId);
            }
            monster.intervalId = setInterval(() => {
                moveMonster(monster);
            }, monster.type.speed);
        }

        function clearAllMonsterIntervals() {
            monsters.forEach(m => {
                if (m.intervalId) {
                    clearInterval(m.intervalId);
                }
            });
            if (chaseIntervalId) {
                clearInterval(chaseIntervalId);
                chaseIntervalId = null;
            }
        }
        
        function placeItems(map) {
            const pathCells = [];
            for (let y = 1; y < GRID_SIZE - 1; y++) {
                for (let x = 1; x < GRID_SIZE - 1; x++) {
                    if (map[y][x] === 0) {
                        pathCells.push({ x, y });
                    }
                }
            }
            
            for (let i = 0; i < 5 && pathCells.length > 0; i++) {
                const index = Math.floor(Math.random() * pathCells.length);
                const cell = pathCells.splice(index, 1)[0];
                map[cell.y][cell.x] = 4;
            }
        }

        function resetGame() {
            gameState = 'playing';
            player.x = 1;
            player.y = 1;
            player.isBoosted = false;
            keysPressed = {}; 
            fearMeter = 0; 
            
            clearAllMonsterIntervals();
            monsters = [];
            
            if (playerBoostTimeout) clearTimeout(playerBoostTimeout);
            if (playerBoostInterval) clearInterval(playerBoostInterval);
            if (playerMovementIntervalId) clearInterval(playerMovementIntervalId); 
            if (chaseIntervalId) clearInterval(chaseIntervalId);

            MAP = generateMaze(GRID_SIZE, GRID_SIZE);
            placeItems(MAP);

            overlay.classList.remove('active', 'flash', 'glitch');
            gameContainer.classList.remove('shake');
            timerBar.classList.remove('active');
            boostBar.classList.remove('active');
            statusMessage.textContent = "Gebruik WASD of Pijltjestoetsen om te bewegen. Vind de Uitgang (Groen).";
            
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            updatePlayerMoveSpeed(PLAYER_BASE_MOVE_SPEED); 
            setupCanvas();
            drawGame();
        }

        function setupCanvas() {
            canvas.width = VIEWPORT_SIZE;
            canvas.height = VIEWPORT_SIZE;
        }

        function drawGame() {
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--path-color');
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const emojiSizeRatio = 0.6;
            const emojiFontSize = CELL_SIZE * emojiSizeRatio;

            const centerX = VIEWPORT_SIZE / 2;
            const centerY = VIEWPORT_SIZE / 2;
            
            const offsetX = centerX - (player.x * CELL_SIZE + CELL_SIZE / 2);
            const offsetY = centerY - (player.y * CELL_SIZE + CELL_SIZE / 2);

            const cellsHorizontal = Math.ceil(VIEWPORT_SIZE / CELL_SIZE) + 2; 
            const cellsVertical = Math.ceil(VIEWPORT_SIZE / CELL_SIZE) + 2;
            
            const startX = Math.max(0, player.x - Math.floor(cellsHorizontal / 2));
            const endX = Math.min(GRID_SIZE, player.x + Math.ceil(cellsHorizontal / 2));
            const startY = Math.max(0, player.y - Math.floor(cellsVertical / 2));
            const endY = Math.min(GRID_SIZE, player.y + Math.ceil(cellsVertical / 2));

            ctx.font = `${emojiFontSize}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const type = MAP[y][x];
                    const px = x * CELL_SIZE + offsetX;
                    const py = y * CELL_SIZE + offsetY;
                    
                    if (type === 1) {
                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--wall-color');
                        ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                    } else if (type === 2) {
                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--exit-color');
                        ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                    } else if (type === 4) {
                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--path-color'); 
                        ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE); 
                        ctx.fillText('ü•§', px + CELL_SIZE / 2, py + CELL_SIZE / 2);
                    } else if (type === 0) {
                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--path-color');
                        ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
            
            if (gameState === 'chased') {
                monsters.forEach(monster => {
                    if (monster.x >= startX && monster.x < endX && monster.y >= startY && monster.y < endY) {
                        const monsterX_px = monster.x * CELL_SIZE + CELL_SIZE / 2 + offsetX;
                        const monsterY_px = monster.y * CELL_SIZE + CELL_SIZE / 2 + offsetY;
                        ctx.fillText(monster.type.emoji, monsterX_px, monsterY_px);
                    }
                });
            }

            const playerRadius = CELL_SIZE * 0.3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, playerRadius, 0, Math.PI * 2);
            
            if (player.isBoosted) {
                ctx.shadowBlur = 10;
                ctx.shadowColor = getComputedStyle(document.documentElement).getPropertyValue('--player-boost-color');
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--player-boost-color'); 
            } else {
                ctx.shadowBlur = 0;
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--player-base-color');
            }
            
            ctx.fill();
            ctx.closePath();
            ctx.shadowBlur = 0; 
        }

        function checkCollision(x, y) {
            if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) {
                return true; 
            }
            return MAP[y][x] === 1; 
        }
        
        function moveMonster(monster) {
            if (gameState !== 'chased') return;

            const pathResult = findPathBFS(monster.x, monster.y, player.x, player.y);
            const nextStep = pathResult.nextStep;
            
            if (nextStep) {
                monster.x = nextStep.x;
                monster.y = nextStep.y;

                if (monster.x === player.x && monster.y === player.y) {
                    handleDeath(monster.type.name);
                    return;
                }
            } 
            
            drawGame();
        }
        
        function applyPlayerBoost() {
            player.isBoosted = true;
            statusMessage.textContent = "ü•§ SNELHEIDSBOOST! Beweeg sneller voor 5 seconden!";
            boostBar.classList.add('active');
            
            updatePlayerMoveSpeed(PLAYER_BOOST_MOVE_SPEED); 
            
            if (playerBoostTimeout) clearTimeout(playerBoostTimeout);
            if (playerBoostInterval) clearInterval(playerBoostInterval);

            let boostElapsedTime = 0;
            playerBoostInterval = setInterval(() => {
                boostElapsedTime += 100;
                const progress = Math.max(0, 1 - (boostElapsedTime / PLAYER_BOOST_TIME)) * 100;
                boostProgress.style.width = `${progress}%`;
                
                if (boostElapsedTime >= PLAYER_BOOST_TIME) {
                    endPlayerBoost("Snelheid vervaagt...");
                }
            }, 100);

            playerBoostTimeout = setTimeout(() => {
                endPlayerBoost("Snelheid vervaagt...");
            }, PLAYER_BOOST_TIME);
        }
        
        function endPlayerBoost(message) {
            player.isBoosted = false;
            boostBar.classList.remove('active');
            statusMessage.textContent = message;
            
            updatePlayerMoveSpeed(PLAYER_BASE_MOVE_SPEED); 
            
            if (playerBoostInterval) clearInterval(playerBoostInterval);

            setTimeout(() => {
                if (gameState === 'playing') statusMessage.textContent = "Gebruik WASD of Pijltjestoetsen om te bewegen. Vind de Uitgang (Groen).";
            }, 1000);
            drawGame();
        }
        
        function spawnMonster(monsterType) {
            const { distanceMap } = findPathBFS(player.x, player.y);
            
            const validSpawnPoints = [];
            distanceMap.forEach((distance, key) => {
                const [x, y] = key.split(',').map(Number);
                
                if ((MAP[y][x] === 0 || MAP[y][x] === 4) && 
                    distance >= MIN_PATH_DISTANCE_SPAWN && 
                    distance <= MAX_PATH_DISTANCE_SPAWN) {
                    
                    const isOccupied = monsters.some(m => m.x === x && m.y === y);
                    
                    if (!isOccupied) {
                        validSpawnPoints.push({ x, y });
                    }
                }
            });

            if (validSpawnPoints.length > 0) {
                const index = Math.floor(Math.random() * validSpawnPoints.length);
                const { x: mx, y: my } = validSpawnPoints[index];
                
                const newMonster = {
                    x: mx,
                    y: my,
                    type: monsterType,
                    intervalId: null 
                };
                monsters.push(newMonster);
                startMonsterMovement(newMonster);
                return true;
            }
            return false;
        }

        function triggerChase() {
            if (gameState !== 'playing') return;

            gameState = 'chased';
            chaseTimer = CHASE_DURATION;
            clearAllMonsterIntervals(); 

            monsters = []; 
            fearMeter = 0; 
            
            const rand = Math.random();
            let spawnCM = false;
            let spawnBCM = false;
            let monsterNames = [];
            
            if (rand < 0.20) { 
                spawnCM = true;
                spawnBCM = true;
            } else { 
                if (Math.random() < 0.5) {
                    spawnCM = true;
                } else {
                    spawnBCM = true;
                }
            }

            let success = false;
            if (spawnCM) {
                if (spawnMonster(MONSTER_TYPES.CM)) {
                    monsterNames.push(MONSTER_TYPES.CM.name);
                    success = true;
                }
            }
            if (spawnBCM) {
                if (spawnMonster(MONSTER_TYPES.BCM)) {
                    monsterNames.push(MONSTER_TYPES.BCM.name);
                    success = true;
                }
            }
            
            if (!success || monsters.length === 0) {
                gameState = 'playing';
                return;
            }
            
            gameContainer.classList.add('shake');
            timerBar.classList.add('active');
            
            let message;
            if (monsters.length === 2) {
                message = "!!! BEIDE MONSTERS ZIJN JE AAN HET JAGEN! REN! !!!";
                timerProgress.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--monster-bcm-color');
            } else {
                message = `!!! GEVAAR! ${monsterNames[0].toUpperCase()} IS JE AAN HET JAGEN! REN! !!!`;
                timerProgress.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--monster-cm-color');
            }
            statusMessage.textContent = message;

            chaseIntervalId = setInterval(() => {
                chaseTimer -= 100; 
                const progress = Math.max(0, chaseTimer / CHASE_DURATION) * 100;
                timerProgress.style.width = `${progress}%`;

                if (chaseTimer <= 0) {
                    endChase("Ze zijn verdwenen in de duisternis.");
                }
            }, 100);
        }

        function endChase(message) {
            gameState = 'playing';
            clearAllMonsterIntervals();
            monsters = []; 
            fearMeter = 0; 
            
            gameContainer.classList.remove('shake');
            timerBar.classList.remove('active');
            statusMessage.textContent = message;
            
            setTimeout(() => {
                if (gameState === 'playing') statusMessage.textContent = "Gebruik WASD of Pijltjestoetsen om te bewegen. Vind de Uitgang (Groen).";
            }, 2000);
            
            drawGame();
        }

        function handleDeath(monsterName) {
            if (gameState === 'dead') return;

            gameState = 'dead';
            clearAllMonsterIntervals();
            if (playerBoostTimeout) clearTimeout(playerBoostTimeout);
            if (playerBoostInterval) clearInterval(playerBoostInterval);
            if (playerMovementIntervalId) clearInterval(playerMovementIntervalId);

            playJumpscareSound();
            setTimeout(playJumpscareSound, 80);

            gameContainer.classList.add('shake');
            overlay.classList.add('active', 'flash', 'glitch');

            const jumpscareTextEl = document.getElementById('jumpscare-text');
            const captionEl = document.getElementById('jumpscare-caption');
            const monsterEl = document.getElementById('jumpscare-monster');

            if (monsterName.toLowerCase().includes('kaas')) {
                monsterEl.textContent = 'üßÄ';
            } else if (monsterName.toLowerCase().includes('kip')) {
                monsterEl.textContent = 'üçó';
            } else {
                monsterEl.textContent = 'üëÅÔ∏è';
            }

            setTimeout(() => {
                overlay.classList.remove('flash');
                gameContainer.classList.remove('shake');

                overlay.style.backgroundColor = '#000';

                let fullText;
                if (monsterName.toLowerCase().includes('kaas')) {
                    fullText = `GAME OVER\nNAH BRO IS OPGEGETEN DOOR KAAS!`;
                } else if (monsterName.toLowerCase().includes('kip')) {
                    fullText = `GAME OVER\nJE ZOU MAAR OPGEGETEN ZIJN DOOR BUTTER CHICKEN!`;
                } else {
                    fullText = `GAME OVER\n HAHA JE BENT KAPOT SLECHT...`;
                }

                jumpscareTextEl.textContent = '';
                captionEl.textContent = '';

                let i = 0;
                jumpscareTextEl.style.opacity = 1;

                const typeInterval = setInterval(() => {
                    jumpscareTextEl.textContent = fullText.slice(0, i);
                    i++;
                    if (i > fullText.length) {
                        clearInterval(typeInterval);
                        setTimeout(() => {
                            captionEl.textContent = "Druk op een willekeurige toets, klik of tik om opnieuw te beginnen.";
                            captionEl.style.opacity = 1;
                        }, 350);
                    }
                }, 35);
            }, 280);

            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);

            const restartHandler = (event) => {
                event.preventDefault();
                event.stopPropagation();

                Tone.start(); 

                overlay.classList.remove('active', 'flash', 'glitch');
                overlay.style.backgroundColor = '';
                const jumpscareTextEl = document.getElementById('jumpscare-text');
                const captionEl = document.getElementById('jumpscare-caption');
                jumpscareTextEl.textContent = '';
                jumpscareTextEl.style.opacity = 0;
                captionEl.textContent = '';
                captionEl.style.opacity = 0;

                resetGame();

                overlay.removeEventListener('click', restartHandler);
                overlay.removeEventListener('keydown', restartHandler);
                overlay.removeEventListener('touchend', restartHandler);
            };

            overlay.addEventListener('click', restartHandler, { once: true });
            overlay.addEventListener('keydown', restartHandler, { once: true });
            overlay.addEventListener('touchend', restartHandler, { once: true });
        }

        function showWinScreen() {
            const jumpscareTextEl = document.getElementById('jumpscare-text');
            const captionEl = document.getElementById('jumpscare-caption');
            const monsterEl = document.getElementById('jumpscare-monster');

            gameContainer.classList.remove('shake');
            overlay.classList.add('active');
            overlay.classList.remove('flash', 'glitch');
            overlay.style.backgroundColor = '#000';

            monsterEl.textContent = 'üèÜ';

            const fullText = `GEWONNEN\nJE ONTSNAPTE UIT HET DUBBELE MONSTER DOOLHOF LUCKY`;
            jumpscareTextEl.textContent = '';
            captionEl.textContent = '';

            let i = 0;
            jumpscareTextEl.style.opacity = 1;
            captionEl.style.opacity = 0;

            const typeInterval = setInterval(() => {
                jumpscareTextEl.textContent = fullText.slice(0, i);
                i++;
                if (i > fullText.length) {
                    clearInterval(typeInterval);
                    setTimeout(() => {
                        captionEl.textContent = "Klik / toets / tik om een nieuw doolhof te spelen.";
                        captionEl.style.opacity = 1;
                    }, 350);
                }
            }, 35);

            const restartHandler = (event) => {
                event.preventDefault();
                event.stopPropagation();

                overlay.classList.remove('active', 'flash', 'glitch');
                overlay.style.backgroundColor = '';
                jumpscareTextEl.textContent = '';
                jumpscareTextEl.style.opacity = 0;
                captionEl.textContent = '';
                captionEl.style.opacity = 0;

                resetGame();

                overlay.removeEventListener('click', restartHandler);
                overlay.removeEventListener('keydown', restartHandler);
                overlay.removeEventListener('touchend', restartHandler);
            };

            overlay.addEventListener('click', restartHandler, { once: true });
            overlay.addEventListener('keydown', restartHandler, { once: true });
            overlay.addEventListener('touchend', restartHandler, { once: true });
        }
        
        function trySingleMove(dx, dy) {
            const newX = player.x + dx;
            const newY = player.y + dy;

            if (!checkCollision(newX, newY)) {
                player.x = newX;
                player.y = newY;
                
                const currentCell = MAP[newY][newX];
                
                if (currentCell === 2) {
                    gameState = 'won';
                    endChase("JE BENT ONTSNAPT LUCKY");
                    statusMessage.textContent = "JE HEBT GEWONNEN";
                    document.removeEventListener('keydown', handleKeyDown);
                    document.removeEventListener('keyup', handleKeyUp);
                    if (playerMovementIntervalId) clearInterval(playerMovementIntervalId);
                    showWinScreen();
                    return true;
                }
                
                if (currentCell === 4) {
                    MAP[newY][newX] = 0; 
                    applyPlayerBoost();
                }

                if (gameState === 'chased') {
                    for (const monster of monsters) {
                        if (monster.x === newX && monster.y === newY) {
                            handleDeath(monster.type.name);
                            return true;
                        }
                    }
                }
                
                return true; 
            }
            return false; 
        }

        function handleMoveStep(dx, dy) {
            const firstMove = trySingleMove(dx, dy);

            if (firstMove) {
                if (gameState === 'playing') {
                    fearMeter++;
                    
                    if (fearMeter >= STEPS_BEFORE_CHANCE_CHECK) {
                        if (Math.random() < PROGRESSIVE_JUMPSCARE_CHANCE) {
                            triggerChase();
                        } else {
                            fearMeter = 0; 
                        }
                    }
                }
                
                if (player.isBoosted && firstMove) {
                    trySingleMove(dx, dy);
                }
            }
            
            drawGame();
        }

        function getNormalizedKey(key) {
            const map = {
                'w': 'w', 'W': 'w', 'ArrowUp': 'ArrowUp',
                's': 's', 'S': 's', 'ArrowDown': 'ArrowDown',
                'a': 'a', 'A': 'a', 'ArrowLeft': 'ArrowLeft',
                'd': 'd', 'D': 'd', 'ArrowRight': 'ArrowRight',
            };
            return map[key] || null;
        }

        function handleKeyDown(event) {
            if (gameState === 'dead' || gameState === 'won' || gameState === 'loading') return;

            const key = getNormalizedKey(event.key);
            if (key) {
                keysPressed[key] = true; 
                
                if (!playerMovementIntervalId) {
                    startPlayerMovementLoop();
                }
            }
            event.preventDefault(); 
        }
        
        function handleKeyUp(event) {
            if (gameState === 'dead' || gameState === 'won' || gameState === 'loading') return;
            
            const key = getNormalizedKey(event.key);
            if (key) {
                keysPressed[key] = false;
            }
            event.preventDefault();
        }
        
        window.movePlayer = function(direction) {
            if (gameState === 'dead' || gameState === 'won' || gameState === 'loading') return;
            
            let keyToPress;
            if (direction === 'up') keyToPress = 'ArrowUp';
            else if (direction === 'down') keyToPress = 'ArrowDown';
            else if (direction === 'left') keyToPress = 'ArrowLeft';
            else if (direction === 'right') keyToPress = 'ArrowRight';
            
            if (keyToPress) {
                keysPressed[keyToPress] = true;
                if (!playerMovementIntervalId) {
                    startPlayerMovementLoop();
                }
            }
        };

        window.stopMove = function() {
            keysPressed['ArrowUp'] = false;
            keysPressed['ArrowDown'] = false;
            keysPressed['ArrowLeft'] = false;
            keysPressed['ArrowRight'] = false;
            keysPressed['w'] = false;
            keysPressed['s'] = false;
            keysPressed['a'] = false;
            keysPressed['d'] = false;
        };
        
        function handleLoadingComplete() {
            initAudio();
            loadingScreen.style.opacity = '0';
            
            setTimeout(() => {
                loadingScreen.style.display = 'none';
                resetGame(); 
            }, 1000); 
        }

        window.onload = function() {
            setupCanvas();
            setTimeout(handleLoadingComplete, 2000); 
            window.addEventListener('resize', setupCanvas); 
        };
    </script>

</body>
</html>
